<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ubuntu上安装composer和laravel]]></title>
    <url>%2F2018%2F10%2F05%2Fubuntu%2Blaravel%2F</url>
    <content type="text"><![CDATA[ubuntu上安装PHP框架laravel。 准备服务器要求laravel框架对系统的要求可以用Laravel Homestead 虚拟机满足，如果不使用Homestead作为开发环境需要服务器符合以下要求： PHP &gt;= 7.0.0 PHP OpenSSL 扩展 PHP PDO 扩展 PHP Mbstring扩展 PHP Tokenizer 扩展 PHP XML 扩展 安装PHP扩展 安装配置composer安装composer依次输入下面命令安装composer 1php -r &quot;copy(&apos;https://install.phpcomposer.com/installer&apos;,&apos;composer-setup.php&apos;);&quot;下载安装脚本 － composer-setup.php － 到当前目录。 1php composer-setup.php执行安装过程 1php -r &quot;unlink(&apos;composer-setup.php&apos;);&quot;删除安装脚本 全局安装 1sudo mv composer.phar /usr/local/bin/composer 安装完以后查看composer版本 composer -v 说明安装成功了。 配置composer修改composer的全局配置文件 1composer config -g repo.packagist composer https://packagist.phpcomposer.com 然后执行 composer selfupdate 安装配置laravel安装laravel 1composer global require &quot;laravel/installer=~1.1&quot; 配置laravel使用下面语句添加环境变量1export PATH=&quot;~/.config/composer/vendor/bin:$PATH&quot; 并填加在 /etc/bash.bashrc 执行 source ~/.bashrc 让环境变量立即生效 然后就去 /var/www新建一个laravel项目 1laravel new laravel 在laravel new的时候会报几个文件没有权限，直接给777权限就OK了。 修改laravel目录权限 12sudo chown -R :www-data /var/www/laravelsudo chmod -R 775 /var/www/laravel/storage 然后laravel就弄好了，可以开始表演了。]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu上nginx+PHP7.1+mysql的安装及配置]]></title>
    <url>%2F2018%2F10%2F05%2Fubuntu%2Bnginx%2BPHP7.1%2Bmysql%2F</url>
    <content type="text"><![CDATA[ubuntu16.04上安装nginx+PHP7.1+mysql 初始工作——换源换源就是更新软件的下载源，ubuntu如果没有换源的话，默认源是欧洲的，下载速度很慢，还有可能报一些404的错误，所以要换成国内的下载源，原来用的是清华的源，但是清华源在某大的时候可能会被墙，换成了较好的163源。 ubuntu的下载源在/etc/apt下的source.list中。 把里面的内容备份后，换成163的源。 下面是ubuntu 16.04的163源12345678910deb http://mirrors.163.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse 保存，退出后，执行下面的命令更新。 安装nginxapt源更新好以后，就可以安装 nginx了 sudo apt-get install nginx 安装好以后可以 nginx -v 看一下nginx的版本 这时候启动nginx 并设置开机启动 然后访问192.168.33.10，可以看到welcome to nginx 安装PHP7.1按以下命令安装PHP 安装后php -v 查看自己是否安装成 这样PHP7.1就安装好了 安装mysql然后安装mysql 安装过程中会让输入root密码，切记啊！ 登入mysql然后使用 Ctrl+D 退出mysql nginx和PHP的配置配置PHP安装php-fpm 1sudo apt install php7.1-fpm 修改 php.ini 文件 1sudo vim /etc/php/7.1/fpm/php.ini 将;cgi.fix_pathinfo=1 修改为 cgi.fix_pathinfo=0（去掉注释）/ 用于搜索 重启php7.1-fpm 1sudo service php7.1-fpm restart 配置nginxNginx的服务器配置文件在/etc/nginx/sites-available的default 1sudo vim /etc/nginx/sites-available/default 做以下修改 然后重启 nginx 1sudo systemctl reload nginx 在1/var/www 下增加test.php文件1sudo vim test.php 输入 123&lt;?php echo phpinfo();?&gt; 访问192.168.33.10/test.php可以看到 已经配置成功啦！！！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vagrant ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vagrant的安装&简单的配置]]></title>
    <url>%2F2018%2F10%2F05%2Fvagrant%2F</url>
    <content type="text"><![CDATA[一般服务器上的运行环境都是Linux，如果开发者项目在本地 （windows）上运行正常的话，放到服务器上会出现一些bug，这是开发环境和生成环境不一致而造成的。这就需要一个和服务器运行环境一致的开发环境。当时打算做个双系统，在做之前组长推荐了vagrant虚拟机，发现内存占用并不是很大，而且还可以在开发的时候用Windows上的软件，非常的方便。 一段时间后组内人的vagrant的虚拟机由于种种扫操作，很多都烂掉了，重装的时候又遇到了各种各样的坑。作为为数不多的vagrant虚拟机还健在的人，被强迫又装了一个，记录了搭建vagrant环境的一些步骤和踩过的坑。 提前准备 先确保电脑已经在BIOS中开启了虚拟化技术（大部分Windows笔记本可以通过拿小针插电源插口旁的小孔进入BIOS设置。进入后在Configuration中将Intel Virtualization Technology改为Enable，然后保存并退出。） 安装VirtualBox下载后一路傻瓜式安装（不要安装最新版——来自组长的提醒 ） 安装vagrant下载后一路傻瓜式安装(先安装VirtualBox在安装vagrant) vagrant up &amp; ssh提前准备在做好以后就可以开始搞事情了。创建一个文件夹，命名为ubuntu。可以利用git bash、cmder或者cmd进入这个文件夹。然后选一个Vagrant Box(我选的是Ubuntu 16.04，以此为例) 也可以迅雷下载box，然后添加到ubuntu文件夹中，然后 vagrant init box的名称接下啦，运行vagrant up启动虚拟机。将会非常漫长。up好以后打开VirtualBox客户端可以看到虚拟机已经正常启动。打开ubuntu会出有vagrantfile和.vagrant文件夹up好以后就可以通过ssh访问虚拟机，部分电脑用git bash会出现这种情况很无奈，只好用cmd ssh登录了到此，vagrant就安装好了。 vagrant配置vagrant端口转发在vagrantfile中取消下面几行的注释 具体的vagrant的三种网络配置的作用可以参考这篇博文：Vagrant 三种网络配置详解 vagrant 共享文件夹在vagrantfile中进行修改这样我就可以在把项目放在D盘的project下，然后在主机使用IDE写代码，在虚拟机中运行。最后记得vagrant reload 重启vagrant，让vagrantfile里面的配置生效 本机连接vagrant的mysql修改 mysql的配置文件my.cnf ubuntu16.04应该在1/etc/mysql/mysql.conf.d 将mysqld.cnf中的bind_address=127.0.0.1修改为bind_address=0.0.0.0 重启mysql sudo service mysql reload 然后设置mysql允许远程访问 1234mysql -u root -puse mysql;update user set host = &apos;%&apos; where user = &apos;root&apos;;exit; 然后重启一下vagrant Updating]]></content>
      <categories>
        <category>vagrant</category>
      </categories>
      <tags>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集&字符编码以及PHP中的一些转码方法]]></title>
    <url>%2F2018%2F10%2F05%2FCharater%20set-PHP%2F</url>
    <content type="text"><![CDATA[在重写一些老的项目的时候，有可能会遇到这种情况 ¾ÍÒµÖ¸µ¼ÖÐÐÄ2010Äêº®¼Ù·Å¼ÙÍ¨Öª �����˵�λ������� ???????? 这就是传说中的乱码，要想处理乱码，得先了解字符集&amp;字符编码。 字符集&amp;编码计算机中储存的信息都是用二进制数表示的；我们直接看到的英文、汉字等字符是二进制数转换之后的结果。通俗的说，按照何种规则将字符存储在计算机中，如’a’用什么表示，称为”编码”；反之，将存储在计算机中的二进制数解析显示出来，称为”解码”。 在解码过程中，如果使用了错误的解码规则，则导致’a’解析成’b’或者乱码。 字符集（Charset）：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。 字符编码（Character Encoding）：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。 常用的字符集常见的字符集：ASCII字符集，ISO8859-1字符集， GB2312字符集， GBK字符集，BIG5字符集、GB18030字符集、Unicode字符集等 ASII字符集&amp;编码ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以勉强显示其他西欧语言。它是现今最通用的单字节编码系统（但是有被Unicode追上的迹象），并等同于国际标准ISO/IEC 646。 ASCII字符集：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 ASCII编码：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展， ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。 缺点: 只能用显示26个基本拉丁字母，阿拉伯数字和英式标点符号。只能用于现代英语。EASCII解决了部分西欧语言的问题。 ISO-8859-1字符集&amp;编码ISO-8859-1编码是单字节编码，向下兼容ASCII，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。 此字符集支持部分于欧洲使用的语言，包括阿尔巴尼亚语、巴斯克语、布列塔尼语、加泰罗尼亚语、丹麦语、荷兰语、法罗语、弗里西语、加利西亚语、德语、格陵兰语、冰岛语、爱尔兰盖尔语、意大利语、拉丁语、卢森堡语、挪威语、葡萄牙语、里托罗曼斯语、苏格兰盖尔语、西班牙语及瑞典语。 Latin1是ISO-8859-1的别名，有些环境下写作Latin-1。 GBXXXX字符集&amp;编码编码规则:将127号之后的奇异符号们（即EASCII）取消，规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GB2312。GB2312或GB2312-80是中国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB2312。 GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对一些罕用字，GB2312不能处理，这导致了后来GBK(对GBK2312的扩展，但自身并非国家标准)及GB 18030汉字字符集的出现。 GB 18030，全称：国家标准GB 18030-2005《信息技术 中文编码字符集》，是中华人民共和国现时最新的内码字集，是GB 18030-2000《信息技术 信息交换用汉字编码字符集 基本集的扩充》的修订版。与GB 2312-1980完全兼容，与GBK基本兼容，支持GB 13000及Unicode的全部统一汉字，共收录汉字70244个。 GB 18030的特点： 与UTF-8相同，采用多字节编码，每个字可以由1个、2个或4个字节组成。 编码空间庞大，最多可定义161万个字符。 支持中国国内少数民族的文字，不需要动用造字区。 汉字收录范围包含繁体汉字以及日韩汉字 BIG5字符集&amp;编码Big5，又称为大五码或五大码，是使用繁体中文（正体中文）社区中最常用的电脑汉字字符集标准，共收录13,060个汉字。中文码分为内码及交换码两类，Big5属中文内码，知名的中文交换码有CCCII、CNS11643。Big5虽普及于台湾、香港与澳门等繁体中文通行区，但长期以来并非当地的国家标准，而只是业界标准。倚天中文系统、Windows等主要系统的字符集都是以Big5为基准。 Big5码是一套双字节字符集，使用了双八码存储方法，以两个字节来安放一个字。第一个字节称为”高位字节”，第二个字节称为”低位字节”。”高位字节”使用了0x81-0xFE，”低位字节”使用了0x40-0x7E，及0xA1-0xFE。 UnicodeUnicode是字符集，UTF-32/ UTF-16/ UTF-8是三种字符编码方案。 Unicode（统一码、万国码、单一码、标准万国码）。为表达任意语言的任意字符而设计。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。每个数字代表唯一的至少在某种语言中使用的符号。nUnicode用数字0-0x10FFFF来映射这些字符，最多可以容纳1114112个字符，或者说有1114112个码位。 UTF-32上述使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。UTF-32又称UCS-4是一种将Unicode字符编码的协定，对每个字符都使用4字节。就空间而言，是非常没有效率的。 这种方法有其优点，最重要的一点就是可以在常数时间内定位字符串里的第N个字符，因为第N个字符从第4×Nth个字节开始。虽然每一个码位使用固定长定的字节看似方便，它并不如其它Unicode编码使用得广泛。 UTF-16尽管有Unicode字符非常多，但是实际上大多数人不会用到超过前65535个以外的字符。因此，就有了另外一种Unicode编码方式，叫做UTF-16(因为16位 = 2字节)。UTF-16将0–65535范围内的字符编码成2个字节，如果真的需要表达那些很少使用的”星芒层(astral plane)”内超过这65535范围的Unicode字符，则需要使用一些诡异的技巧来实现。UTF-16编码最明显的优点是它在空间效率上比UTF-32高两倍，因为每个字符只需要2个字节来存储（除去65535范围以外的），而不是UTF-32中的4个字节。 其编码方法是： 如果字符编码U小于0x10000，也就是十进制的0到65535之内，则直接使用两字节表示； 如果字符编码U大于0x10000，由于UNICODE编码范围最大为0x10FFFF，从0x10000到0x10FFFF之间 共有0xFFFFF个编码，也就是需要20个bit就可以标示这些编码。用U’表示从0-0xFFFFF之间的值，将其前 10 bit作为高位和16 bit的数值0xD800进行 逻辑or 操作，将后10 bit作为低位和0xDC00做 逻辑or 操作，这样组成的 4个byte就构成了U的编码。 UTF-8UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码（定长码），也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部份修改，即可继续使用。 互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。 UTF-8使用一至四个字节为每个字符编码： 128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。 带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码（Unicode范围由U+0080至U+07FF）。 其他基本多文种平面（BMP）中的字符（这包含了大部分常用字）使用三个字节编码。 其他极少使用的Unicode辅助平面的字符使用四字节编码。 优点 ​ UTF-8是ASCII的一个超集。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。 使用标准的面向字节的排序例程对UTF-8排序将产生与基于Unicode代码点排序相同的结果。（尽管这只有有限的有用性，因为在任何特定语言或文化下都不太可能有仍可接受的文字排列顺序。） UTF-8和UTF-16都是可扩展标记语言文档的标准编码。所有其它编码都必须通过显式或文本声明来指定。 任何面向字节的字符串搜索算法都可以用于UTF-8的数据（只要输入仅由完整的UTF-8字符组成）。但是，对于包含字符记数的正则表达式或其它结构必须小心。 UTF-8字符串可以由一个简单的算法可靠地识别出来。 缺点 因为每个字符使用不同数量的字节编码，所以寻找串中第N个字符是一个O(N)复杂度的操作 — 即，串越长，则需要更多的时间来定位特定的字符。同时，还需要位变换来把字符编码成字节，把字节解码成字符。 PHP的一些转码函数iconv(PHP 4 &gt;= 4.0.5, PHP 5, PHP 7) iconv — 字符串按要求的字符编码来转换 说明string iconv ( string $in_charset , string $out_charset , string $str ) 将字符串 str 从 in_charset 转换编码到 out_charset。 参数 in_charset 输入的字符集。 out_charset 输出的字符集。如果你在 out_charset 后添加了字符串 //TRANSLIT，将启用转写（transliteration）功能。这个意思是，当一个字符不能被目标字符集所表示时，它可以通过一个或多个形似的字符来近似表达。 如果你添加了字符串 //IGNORE，不能以目标字符集表达的字符将被默默丢弃。 否则，会导致一个 E_NOTICE并返回 FALSE。 Caution//TRANSLIT 运行细节高度依赖于系统的 iconv() 实现。 据悉，某些系统上的实现会直接忽略 //TRANSLIT，所以转换也有可能失败，out_charset 会是不合格的。 str 要转换的字符串。 返回值 返回转换后的字符串， 或者在失败时返回 FALSE。 用法\$text = iconv(“UTF-8”, “ISO-8859-1//TRANSLIT”, $text); \$text = iconv(“UTF-8”, “ISO-8859-1//IGNORE”, $text); \$text = iconv(“UTF-8”, “ISO-8859-1”, $text); mb_convert_encoding(PHP 4 &gt;= 4.0.6, PHP 5, PHP 7) mb_convert_encoding — 转换字符的编码 说明string mb_convert_encoding ( string $str , string $to_encoding [, mixed $from_encoding = mb_internal_encoding() ] ) 将 string 类型 str 的字符编码从可选的 from_encoding 转换到 to_encoding。 参数str 要编码的 string。 to_encoding str 要转换成的编码类型。 from_encoding 在转换前通过字符代码名称来指定。它可以是一个 array 也可以是逗号分隔的枚举列表。 如果没有提供 from_encoding，则会使用内部（internal）编码。 支持的编码。 返回值编码后的 string 用法\$str = mb_convert_encoding($str, “SJIS”); / 将 EUC-JP 转换成 UTF-7 / \$str = mb_convert_encoding($str, “UTF-7”, “EUC-JP”); / 从 JIS, eucjp-win, sjis-win 中自动检测编码，并转换 str 到 UCS-2LE / \$str = mb_convert_encoding($str, “UCS-2LE”, “JIS, eucjp-win, sjis-win”); / “auto” 扩展成 “ASCII,JIS,UTF-8,EUC-JP,SJIS” / \$str = mb_convert_encoding($str, “EUC-JP”, “auto”); iconv和mb_convert_encoding的区别1、iconv速度快，自然优先选择，但是他有个缺点，如果遇到自己不能转换的字符，就从那里截断。这就导致转码中内容被无故截断。 2、mb_convert_encoding函数效率比较低，但是他遇到无法转换的内容不会截断，这很大程度保留了内容的完整性。但是我发现比如内容有空格，转换出来的内容就有？符号，还是不够完美。]]></content>
      <categories>
        <category>Character</category>
      </categories>
      <tags>
        <tag>PHP 字符编码 字符集</tag>
      </tags>
  </entry>
</search>
